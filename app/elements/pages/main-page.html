<!--
  ~ Copyright (c) 2016-2017, Michael A. Updike All rights reserved.
  ~ Licensed under Apache 2.0
  ~ https://opensource.org/licenses/Apache-2.0
  ~ https://goo.gl/wFvBM1
  -->
<link rel="import" href="../../bower_components/polymer/polymer.html">

<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../../bower_components/iron-selector/iron-selector.html">

<link rel="import" href="../../bower_components/paper-styles/typography.html">
<link rel="import" href="../../bower_components/paper-styles/color.html">
<link rel="import" href="../../bower_components/paper-material/paper-material.html">
<link rel="import" href="../../bower_components/paper-toolbar/paper-toolbar.html">
<link rel="import" href="../../bower_components/paper-toggle-button/paper-toggle-button.html">
<link rel="import" href="../../bower_components/paper-tooltip/paper-tooltip.html">
<link rel="import" href="../../bower_components/paper-dialog/paper-dialog.html">
<link rel="import" href="../../bower_components/paper-dialog-scrollable/paper-dialog-scrollable.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/paper-listbox/paper-listbox.html">
<link rel="import" href="../../bower_components/paper-item/paper-icon-item.html">
<link rel="import" href="../../bower_components/paper-item/paper-item.html">
<link rel="import" href="../../bower_components/paper-item/paper-item-body.html">
<link rel="import" href="../../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../bower_components/paper-toast/paper-toast.html">

<link rel="import" href="../my_icons.html">

<script type="text/javascript"
        src="../../bower_components/chrome-extension-utils/scripts/exception_handler.js"></script>

<dom-module id="main-page">
  <template>
    <style include="iron-flex iron-flex-alignment iron-flex-factors iron-positioning"></style>
    <style include="shared-styles"></style>
    <style>
      :host {
        display: block;
        position: relative;
      }

      .page-content {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
      }

      .page-toolbar {
        margin-bottom: 0;
      }

      .body-content {
        padding-top: 0;
      }

      iron-icon {
        color: var(--accent-color);
      }

      paper-icon-item {
        /*stupid documentation*/
        --paper-item-focused-before: {
          background: transparent;
        };
      }

      #clipList {
        min-width: 600px;
        height: 82vh;
        overflow: hidden;
        overflow-y: scroll;
        border: 1px #CCCCCC;
        border-right-style: solid;
        padding: 0 0 32px 0;
        margin: 0;
      }

      .clip-item {
        position: relative;
        border: 1px #CCCCCC;
        border-bottom-style: solid;
        margin: 0;
        padding: 0 0 0 8px;
        cursor: pointer;
      }

      .clip-item paper-item {
        /*stupid documentation*/
        --paper-item-focused-before: {
          background: transparent;
        };
      }

      .clip-text-row {
        padding-left: 0;
        padding-right: 0;
      }

      .clip-text {
        line-height: 1.2em;
        height: 2.4em;
        overflow: hidden;
        margin-left: 16px;
        margin-right: 16px;
      }

      .date-row {
        padding: 0 8px;
      }

      .date-text {
        color: var(--accent-color);
        text-align: center;
      }

      #clipViewer {
        height: 82vh;
        overflow: hidden;
        overflow-y: scroll;
        padding: 16px;
        margin: 0;
      }

      #clipViewerText {
        @apply(--paper-font-subhead);
        white-space: pre-wrap;
      }

      #clipViewerLabels {
        cursor: pointer;
        margin: 0;
        padding-bottom: 16px;
      }

      #clipViewerLabels paper-item {
        @apply(--paper-font-subhead);
        --paper-item: {
          min-height: 0;
          border: 2px solid rgba(0, 0, 0, .1);
          border-radius: 5px;
          background-color: rgba(0, 0, 0, .1);
          margin-right: 8px;
          margin-bottom: 8px;
          padding-left: 4px;
          padding-right: 4px;
        };
        --paper-item-disabled-color: var(--primary-text-color);
      }

      #labelsDialog {
        min-width: 25vw;
      }

      #undoToastButton {
        margin-top: 0;
        margin-bottom: 0;
        color: yellow;
      }

      .iron-selected {
        background: var(--selected-color);
      }

    </style>

    <paper-material elevation="1" class="page-content">

      <!-- Tool bar -->
      <paper-material elevation="1">
        <paper-toolbar class="page-toolbar">
          <span class="space"></span>
          <div class="middle middle-container center horizontal layout flex">
            <div class="flex">[[_computeTitle(currentClip, labelFilter)]]</div>
            <paper-icon-button
                id="fav" icon="[[_computeFavIcon(isFavFilter)]]"
                style$="color: [[_computeFavMenuColor(isFavFilter)]];"
                on-tap="_onFavFilterTapped"></paper-icon-button>
            <paper-tooltip for="fav" position="left" offset="0">
              [[_computeFavToolTip(isFavFilter)]]
            </paper-tooltip>
            <paper-icon-button
                id="select" icon="myicons:check-box"
                on-tap="_onSelectAllTapped"></paper-icon-button>
            <paper-tooltip for="select" position="left" offset="0">Select all items</paper-tooltip>
            <paper-icon-button
                id="deselect" icon="myicons:check-box-outline-blank"
                on-tap="_onDeselectAllTapped"></paper-icon-button>
            <paper-tooltip for="deselect" position="left" offset="0">Deselect all items</paper-tooltip>
            <paper-icon-button
                id="labels" icon="myicons:label"
                disabled$="[[!hasSelections]]"
                on-tap="_onSelectLabelsTapped"></paper-icon-button>
            <paper-tooltip for="labels" position="left" offset="0">Set labels for selected items</paper-tooltip>
            <paper-icon-button
                id="delete" icon="myicons:delete"
                disabled$="[[!hasSelections]]"
                on-tap="_onDeleteSelectedTapped"></paper-icon-button>
            <paper-tooltip for="delete" position="left" offset="0">Delete selected items</paper-tooltip>
          </div>
        </paper-toolbar>
      </paper-material>

      <!-- Content -->
      <div class="body-content horizontal layout">

        <!-- Select labels dialog -->
        <paper-dialog
            id="labelsDialog" modal
            entry-animation="scale-up-animation"
            exit-animation="fade-out-animation">
          <h2 class="vertical layout center">
            [[_computeLabelsDialogTitle(isMultiLabelsEdit, selectedClips, selectedClips.splices)]]</h2>
          <paper-dialog-scrollable>
            <paper-listbox
                multi attr-for-selected="id"
                selected-values="{{selectedDialogLabels}}">
              <template is="dom-repeat"
                        items="{{labels}}" as="label">
                <paper-icon-item id="[[label]]">
                  <iron-icon icon="myicons:label" item-icon></iron-icon>
                  [[label]]
                </paper-icon-item>
              </template>
            </paper-listbox>
          </paper-dialog-scrollable>
          <div class="buttons">
            <paper-button dialog-dismiss autofocus>CLOSE</paper-button>
          </div>
        </paper-dialog>

        <!-- Undo delete toast -->
        <paper-toast id="undoToast" duration="0">
          <div class="horizontal center layout">
            <span id="undoToastText">[[undoText]]</span>
            <paper-button
                id="undoToastButton"
                on-tap="_onUndoDeleteTapped">UNDO
            </paper-button>
            <paper-icon-button
                id="undoIcon"
                icon="myicons:close"
                on-tap="_onCloseToastTapped"></paper-icon-button>
          </div>
        </paper-toast>

        <!-- Main list -->
        <div id="clipList" class="flex-2">
          <iron-selector
              id="clipsSelector"
              multi attr-for-selected="clip"
              selected-values="{{selectedClips}}">
            <template
                is="dom-repeat" id="clipsTemplate"
                items="{{clips}}" as="clip"
                sort="_sortByDate" filter="_filter" observe="date fav">
              <div
                  tabindex="1"
                  class="clip-item"
                  id="clip[[index]]"
                  clip="{{clip}}"
                  on-tap="_onClipTap">
                <div class="clip-body flex vertical layout" tabindex="-1">
                  <paper-item class="date-row center horizontal layout">
                    <paper-icon-button
                        icon="[[_computeFavIcon(clip.fav)]]"
                        style$="color: [[_computeFavColor(clip.fav)]];"
                        on-tap="_onFavTapped"></paper-icon-button>
                    <paper-item-body class="date-text center flex">
                      {{_computeDate(clip.date)}}
                    </paper-item-body>
                    <paper-icon-button
                        icon="myicons:content-copy"
                        on-tap="_onCopyTapped"></paper-icon-button>
                  </paper-item>
                  <paper-item class="clip-text-row">
                    <paper-item-body class="clip-text fit vertical start-justified layout">
                      [[clip.text]]
                    </paper-item-body>
                  </paper-item>
                </div>
              </div>
            </template>
          </iron-selector>
        </div>

        <!-- Clip Viewer -->
        <div id="clipViewer" class="flex-3">
          <div id="clipViewerLabels" on-tap="_onLabelsTapped">
            <div class="horizontal layout">
              <template
                  is="dom-repeat" id="labelsTemplate"
                  items="{{currentLabels}}" as="currentLabel">
                <paper-item disabled>[[currentLabel]]</paper-item>
              </template>
            </div>
            <hr/>
          </div>
          <div id="clipViewerText"></div>
        </div>

      </div>
    </paper-material>
  </template>
</dom-module>

<script>
  (function() {
    'use strict';

    new ExceptionHandler();

    const _ERR_LOAD = 'Failed to load Clips';

    let self;

    /**
     * Polymer element to display and manage {@link ClipItem} objects
     * @namespace MainPage
     */
    Polymer({

      is: 'main-page',

      properties: {
        /**
         * {@link ClipItem} currently being viewed
         * @memberOf MainPage
         */
        currentClip: {
          type: Object,
          value: null,
          notify: true,
          observer: '_currentClipChanged',
        },

        /**
         * Array of {@link ClipItem} objects filtered by {@link labelFilter}
         * @memberOf MainPage
         */
        clips: {
          type: Array,
          value: [],
          notify: true,
        },

        /**
         * Array of selected {@link ClipItem} objects
         * @memberOf MainPage
         */
        selectedClips: {
          type: Array,
          value: [],
          notify: true,
        },

        /**
         * True if we have selected items
         * @memberOf MainPage
         */
        hasSelections: {
          type: Boolean,
          computed:
              '_computeHasSelections(selectedClips.splices)',
        },

        /**
         * Array of {@link ClipItem} objects that have been recently deleted
         * @memberOf MainPage
         */
        undoClips: {
          type: Array,
          value: [],
          notify: true,
        },

        /**
         * Message of undo toast
         * @memberOf MainPage
         */
        undoText: {
          type: String,
          value: '',
          notify: true,
        },

        /**
         * True if we are only showing favorite items
         * @memberOf MainPage
         */
        isFavFilter: {
          type: Boolean,
          value: false,
          notify: true,
        },

        /**
         * {@link Label} name for filtering our items
         * @memberOf MainPage
         */
        labelFilter: {
          type: String,
          value: null,
          notify: true,
          observer: '_labelFilterChanged',
        },

        /**
         * Array of all {@link Label} names
         * @memberOf MainPage
         */
        labels: {
          type: Array,
          value: [],
          notify: true,
        },

        /**
         * Array of all {@link Label} names for the current clip
         * @memberOf MainPage
         */
        currentLabels: {
          type: Array,
          value: [],
          notify: true,
        },

        /**
         * Array of all selected {@link Label} names in the dialog
         * @memberOf MainPage
         */
        selectedDialogLabels: {
          type: Array,
          value: [],
          notify: true,
        },

        /**
         * True if label changes in dialog should apply to all selectedClips
         * @memberOf MainPage
         */
        isMultiLabelsEdit: {
          type: Boolean,
          value: false,
          notify: true,
        },
      },

      observers: [
        '_selectedClipsAddedOrRemoved(selectedClips.splices)',
        '_selectedDialogLabelsAddedOrRemoved(selectedDialogLabels.splices)',
      ],

      /**
       * Element is ready
       * @memberOf MainPage
       */
      ready: function() {
        self = this;
        this._loadClipItems().catch((err) => {
          Chrome.Log.error(err.message, 'MainPage.ready', _ERR_LOAD);
        });

        // listen for changes to database
        app.DB.get().on('changes', this._onDBChanged);

        // listen for copy and cut events on document
        document.addEventListener('cut', this._onCopy, true);
        document.addEventListener('copy', this._onCopy, true);
      },

      /**
       * We have animated in and are now the current page
       * @memberOf MainPage
       */
      onCurrentPage: function() {
        this._selectFirst(true);
        this.updateDates();
      },

      /**
       * We are not going to be current anymore
       * @memberOf MainPage
       */
      onLeavePage: function() {
        this._closeUndoToast();
      },

      /**
       * Update the relative dates
       * @memberOf MainPage
       */
      updateDates: function() {
        for (let i = 0; i < this.clips.length; i++) {
          const date = this.clips[i].date;
          this.set(`clips.${i}.date`, date - 1);
          this.set(`clips.${i}.date`, date);
        }
      },

      /**
       * Set {@link Label} name for filtering
       * @param {?string} labelName
       * @memberOf MainPage
       */
      setLabelFilter: function(labelName) {
        this.set('labelFilter', labelName);
      },

      /**
       * Event: Fired when changes occur in the Dexie database
       * @see http://dexie.org/docs/Observable/Dexie.Observable.html
       * @param {Array} changes - database changes
       * @private
       * @memberOf MainPage
       */
      _onDBChanged: function(changes) {
        changes.forEach(function(change) {
          switch (change.type) {
            case 1: // CREATED
              if (change.table === 'clipItems') {
                const c = change.obj;
                if (self._getClipPos(c.text) !== -1) {
                  // already in list
                  break;
                }

                const clipItem =
                    new app.ClipItem(c.text, c.date, c.fav, c.remote, c.device);
                clipItem._id = change.key;
                clipItem.labels = c.labels;
                clipItem.labelsId = c.labelsId;
                if (!self.labelFilter || clipItem.hasLabel(self.labelFilter)) {
                  // add to list if not filtering or has our labelFiler
                  self.unshift('clips', clipItem);
                  self._sortClipsByDate();
                  self._select(clipItem);
                  self.updateDates();
                }
              }
              break;
            case 2: // UPDATED
              if (change.table === 'clipItems') {
                const clipItem = change.obj;
                let pos = self._getClipPos(clipItem.text);
                if (pos !== -1) {
                  const str = `clips.${pos}.`;
                  self.set(`${str}_id`, clipItem._id);
                  self.set(`${str}fav`, clipItem.fav);
                  self.set(`${str}date`, clipItem.date);
                  self.set(`${str}remote`, clipItem.remote);
                  self.set(`${str}device`, clipItem.device);
                  self.set(`${str}labels`, clipItem.labels);
                  self.set(`${str}labelsId`, clipItem.labelsId);
                  self._sortClipsByDate();
                  self.updateDates();
                  if (self.currentClip &&
                      (clipItem.text === self.currentClip.text)) {
                    let pos = self._getClipPos(clipItem.text);
                    // bypass dirty checking
                    self.set('currentClip', null);
                    self.set('currentClip', self.clips[pos]);
                  }
                }
              }
              break;
            case 3: // DELETED
              if (change.table === 'clipItems') {
                const clipItem = change.oldObj;
                const pos = self._getClipPos(clipItem.text);
                if (pos !== -1) {
                  self.splice('clips', pos, 1);
                }
              }
              break;
            default:
              break;
          }
        });
      },

      /**
       * Event: Select labels menu icon tapped
       * @private
       * @memberOf MainPage
       */
      _onSelectLabelsTapped: function() {
        this._showLabelsSelectDialog(true);
      },

      /**
       * Event: Labels section of ClipViewer tapped
       * @private
       * @memberOf MainPage
       */
      _onLabelsTapped: function() {
        this._showLabelsSelectDialog(false);
      },

      /**
       * Event: Undo Toast close button tapped
       * @private
       * @memberOf MainPage
       */
      _onCloseToastTapped: function() {
        this._closeUndoToast();
      },

      /**
       * Event: Undo Toast button tapped<br />
       * Restore the deleted Items
       * @private
       * @memberOf MainPage
       */
      _onUndoDeleteTapped: function() {
        const addItems = [];
        this.undoClips.forEach((undoClip) => {
          addItems.push(undoClip);
        });
        app.ClipItem.bulkPut(addItems).then(() => {
          this._closeUndoToast();
          return Promise.resolve();
        }).catch((err) => {
          // some may have failed if the same clipItem text was added again
          // we'll go ahead and commit the successes
          Chrome.Log.error(err.message, 'MainPage.onUndoDeleteTapped',
              'Failed to undo all deletes.');
          this._closeUndoToast();
        });
      },

      /**
       * Event: Select all menu icon tapped
       * @private
       * @memberOf MainPage
       */
      _onSelectAllTapped: function() {
        this.splice('selectedClips', 0, this.selectedClips.length);
        const clips = [];
        for (let i = this.clips.length - 1; i >= 0; i--) {
          const clip = this.clips[i];
          if (this.isFavFilter) {
            if (clip.fav) {
              clips.push(clip);
            }
          } else {
            clips.push(clip);
          }
        }
        this.set('selectedClips', clips);
        this._setCurrentClip();
      },

      /**
       * Event: Deselect all menu icon tapped
       * @private
       * @memberOf MainPage
       */
      _onDeselectAllTapped: function() {
        this.splice('selectedClips', 0, this.selectedClips.length);
      },

      /**
       * Event: Delete menu icon tapped
       * @private
       * @memberOf MainPage
       */
      _onDeleteSelectedTapped: function() {
        this.splice('undoClips', 0, this.undoClips.length);

        let keys = [];
        this.selectedClips.forEach((selectedClip) => {
          keys.push(selectedClip._id);
          this.push('undoClips', selectedClip);
        });

        if (keys.length) {
          app.ClipItem.remove(keys).then(() => {
            this.splice('selectedClips', 0, this.selectedClips.length);
            const len = this.undoClips.length;
            let toastText =
                (len === 1) ? 'Deleted 1 item.' : `Deleted ${len} items.`;
            this.set('undoText', toastText);
            this.$.undoToast.show();
            return Promise.resolve();
          }).catch((err) => {
            Chrome.Log.error(err.message, 'Main._onDeleteSelectedRows');
          });
        }
      },

      /**
       * Event: Favorite filter menu icon tapped
       * @private
       * @memberOf MainPage
       */
      _onFavFilterTapped: function() {
        this.set('isFavFilter', !this.isFavFilter);
        if (this.isFavFilter) {
          // deselect any selected non-fav rows
          if (this.hasSelections) {
            const len = this.selectedClips.length;
            for (let i = len - 1; i >= 0; i--) {
              if (!this.selectedClips[i].fav) {
                this.splice('selectedClips', i, 1);
              }
            }
          }
        }
        this.$.clipsTemplate.render();

      },

      /**
       * Event: Tap on clip row - handle selections like a tree select
       * @param {Event} event
       * @param {ClipItem} event.model.clip
       * @private
       * @memberOf MainPage
       */
      _onClipTap: function(event) {
        const isShift = event.detail.sourceEvent.shiftKey;
        const isCtrl = event.detail.sourceEvent.ctrlKey;
        const clipItem = event.model.clip;
        if (isShift) {
          // select range
          let startPos = this._getClipPos(clipItem.text);
          let endPos = -1;
          if (this._isSelected(clipItem)) {
            // do nothing
            endPos = startPos;
          } else if (!this.hasSelections) {
            // select to newest, inclusive
            endPos = this.clips.length;
          } else {
            for (let i = startPos + 1; i < this.clips.length; i++) {
              // select to newest selected, exclusive
              const clip = this.clips[i];
              if (this._isSelected(clip)) {
                endPos = i;
                break;
              }
            }
            if (endPos === -1) {
              // try other direction
              endPos = startPos + 1;
              for (let i = endPos - 2; i >= 0; i--) {
                // select to oldest selected, exclusive
                const clip = this.clips[i];
                if (this._isSelected(clip)) {
                  startPos = i + 1;
                  break;
                }
              }
            }
          }
          if ((startPos !== -1) && (endPos !== -1)) {
            for (let i = startPos; i < endPos; i++) {
              const clip = this.clips[i];
              if (this.isFavFilter) {
                if (clip.fav) {
                  this.push('selectedClips', clip);
                }
              } else {
                this.push('selectedClips', clip);
              }
            }
          }
        } else if (isCtrl) {
          // toggle selection
          const pos = this._getSelectedClipPos(clipItem.text);
          if (pos === -1) {
            this.push('selectedClips', clipItem);
          } else {
            this.splice('selectedClips', pos, 1);
          }
        } else {
          // single select
          this.splice('selectedClips', 0, this.selectedClips.length);
          this.push('selectedClips', clipItem);
        }

        // prevent iron-selector from handling
        event.stopPropagation();
      },

      /**
       * Event: Copy list row to clipboard
       * @param {Event} event
       * @param {ClipItem} event.model.clip
       * @private
       * @memberOf MainPage
       */
      _onCopyTapped: function(event) {
        const clipItem = event.model.clip;
        clipItem.date = Date.now();
        clipItem.remote = false;
        if (this._isSelected(clipItem)) {
          // deselect if we are selected
          const pos = this.selectedClips.indexOf(clipItem);
          this.splice('selectedClips', pos, 1);
        }
        clipItem.save().then(() => {
          this._selectFirst();
          // send message to copy to clipboard
          const msg =
              Chrome.JSONUtils.shallowCopy(app.ChromeMsg.COPY_TO_CLIPBOARD);
          msg.item = clipItem;
          // eslint-disable-next-line promise/no-nesting
          Chrome.Msg.send(msg).catch(() => {});
          return Promise.resolve();
        }).catch((err) => {
          Chrome.Log.error(err.message, 'Main._onCopyTapped',
              'Failed to copy item to clipboard.');
        });

        // prevent row selection
        event.stopPropagation();
      },

      /**
       * Event: Toggle favorite state of row
       * @param {Event} event
       * @param {ClipItem} event.model.clip
       * @private
       * @memberOf MainPage
       */
      _onFavTapped: function(event) {
        const clipItem = event.model.clip;
        if (clipItem) {
          clipItem.update({fav: !clipItem.fav}).catch((err) => {
            Chrome.Log.error(err.message, 'Main._onFavTapped');
          });
        }

        // prevent row selection
        event.stopPropagation();
      },

      /**
       * Event: Text was copied to clipboard
       * @private
       * @memberOf MainPage
       */
      _onCopy: function() {
        Chrome.Msg.send(app.ChromeMsg.COPIED_TO_CLIPBOARD).catch(() => {});
      },

      /**
       * Observer: The current clip changed
       * @private
       * @memberOf MainPage
       */
      _currentClipChanged: function() {
        // clear text
        const el = this.$.clipViewerText;
        while (el.firstChild) {
          // delete all children previous linkify created
          el.removeChild(el.firstChild);
        }

        // set the current labels

        // not guaranteed to be initialized yet
        if (this.currentLabels === undefined) {
          this.currentLabels = [];
        }

        const clipItem = this.currentClip;
        this.splice('currentLabels', 0, this.currentLabels.length);
        if (!clipItem) {
          this.$.clipViewerLabels.style.display = 'none';
          return;
        }

        const names = clipItem.getLabelNames();
        names.forEach((name) => {
          if (!this.currentLabels.includes(name)) {
            this.push('currentLabels', name);
          }
        });
        // visibility
        if (this.currentLabels && this.currentLabels.length) {
          this.$.clipViewerLabels.style.display = 'block';
        } else {
          this.$.clipViewerLabels.style.display = 'none';
        }

        // set text
        el.textContent = clipItem.text;
        // linkify it - creates element children
        linkifyElement(el);
      },

      /**
       * Observer: The label filter changed
       * @private
       * @memberOf MainPage
       */
      _labelFilterChanged: function() {
        this._loadClipItems().catch((err) => {
          Chrome.Log.error(err.message, 'MainPage.setLabelFilter', _ERR_LOAD);
        });
      },

      /**
       * Observer: selectedClips Array mutations
       * @param {{}} changeRecord
       * @private
       * @memberOf MainPage
       */
      _selectedClipsAddedOrRemoved: function(changeRecord) {
        if (changeRecord) {
          this._setCurrentClip();
        }
      },

      /**
       * Observer: selectedDialogLabels Array mutations
       * @param {{}} changeRecord
       * @private
       * @memberOf MainPage
       */
      _selectedDialogLabelsAddedOrRemoved: function(changeRecord) {
        if (changeRecord) {
          const promises = [];
          if (this.isMultiLabelsEdit) {
            // track each added and removed label change and
            // apply to each selected clip
            const addedNames = [];
            const removedNames = [];
            const splices = changeRecord.indexSplices;
            splices.forEach((splice) => {
              for (let i = 0; i < splice.addedCount; i++) {
                let index = splice.index + i;
                addedNames.push(splice.object[index]);
              }
              splice.removed.forEach((name) => {
                removedNames.push(name);
              });
            });
            this.selectedClips.forEach((clipItem) => {
              const names = clipItem.getLabelNames();
              addedNames.forEach((addedName) => {
                if (!clipItem.hasLabel(addedName)) {
                  names.push(addedName);
                }
              });
              removedNames.forEach((removedName) => {
                if (clipItem.hasLabel(removedName)) {
                  const idx = names.indexOf(removedName);
                  names.splice(idx, 1);
                }
              });
              promises.push(clipItem.setLabels(names));
            });
          } else {
            const clipItem = this.currentClip;
            promises.push(clipItem.setLabels(this.selectedDialogLabels));
          }

          Promise.all(promises).then(() => {
            if (this.labelFilter &&
                !this.selectedDialogLabels.includes(this.labelFilter)) {
              // deleted current label from item(s) 
              this.$.labelsDialog.close();
              return this._loadClipItems();
            } else {
              return Promise.resolve();
            }
          }).catch((err) => {
            Chrome.Log.error(err.errorMessage,
                'MainPage._onSelectedLabelsChanged', 'Failed to set label.');
          });
        }
      },

      /**
       * Computed Property: Do we have selected items
       * @returns {boolean}
       * @private
       * @memberOf MainPage
       */
      _computeHasSelections: function() {
        let ret = false;
        if (this.selectedClips && this.selectedClips.length) {
          ret = true;
        }
        return ret;
      },

      /**
       * Computed Binding
       * @param {ClipItem} clipItem
       * @param {string} labelName
       * @returns {string} Page title
       * @private
       * @memberOf MainPage
       */
      _computeTitle: function(clipItem, labelName) {
        let title = 'Clips: ';
        if (!Chrome.Utils.isWhiteSpace(labelName)) {
          title = `${labelName}: `;
        }
        if (clipItem) {
          if (clipItem.remote) {
            title += `Remote clip - ${clipItem.device}`;
          } else {
            title += 'Local clip';
          }
        }
        return title;
      },

      /**
       * Computed Binding: Title of Labels Dialog
       * @param {boolean} multi - true if dialog applies to all selectedClips
       * @returns {string} Dialog title
       * @private
       * @memberOf MainPage
       */
      _computeLabelsDialogTitle: function(multi) {
        if (multi && this.selectedClips && (this.selectedClips.length > 1)) {
          return 'Set labels for selected clips';
        } else {
          return 'Set labels for the current clip';
        }
      },

      /**
       * Computed Binding
       * @param {boolean} isTrue - true if fav
       * @returns {string} Favorite icon style
       * @private
       * @memberOf MainPage
       */
      _computeFavIcon: function(isTrue) {
        return isTrue ? 'myicons:favorite' : 'myicons:favorite-border';
      },

      /**
       * Computed Binding
       * @param {boolean} isTrue - true if fav
       * @returns {string} Favorite icon color
       * @private
       * @memberOf MainPage
       */
      _computeFavColor: function(isTrue) {
        return isTrue ? 'rgba(255, 0, 0, .8)' : 'var(--primary-text-color)';
      },

      /**
       * Computed Binding
       * @param {boolean} isTrue - true if fav
       * @returns {string} fav filter menu icon color
       * @private
       * @memberOf MainPage
       */
      _computeFavMenuColor: function(isTrue) {
        return isTrue ? 'rgba(255, 0, 0, .8)' : 'var(--menu-icon-color)';
      },

      /**
       * Computed Binding
       * @param {int} date - from epoch in millis
       * @returns {string} Date as relative from now
       * @private
       * @memberOf MainPage
       */
      _computeDate: function(date) {
        return app.Utils.getRelativeTime(date);
      },

      /**
       * Computed Binding
       * @param {boolean} isFilter - true if filtering by fav
       * @returns {string} tooltip text of what toggling would be
       * @private
       * @memberOf MainPage
       */
      _computeFavToolTip: function(isFilter) {
        return isFilter ? 'Show all' : 'Show favorites';
      },

      /**
       * Load the {@link ClipItem} objects
       * @returns {Promise<void>}
       * @private
       * @memberOf MainPage
       */
      _loadClipItems: function() {
        this.splice('clips', 0, this.clips.length);
        this.splice('selectedClips', 0, this.selectedClips.length);
        this._closeUndoToast();
        return app.ClipItem.loadAll(this.labelFilter).then((clipItems) => {
          // populate list
          const clips = [];
          clipItems.forEach((clipItem) => {
            clips.push(clipItem);
          });
          this.set('clips', clips);
          this._selectFirst();
          this.$.clipList.scrollTop = 0;
          return Promise.resolve();
        });
      },

      /**
       * Get position of row with given text
       * @param {string} clipText - text to find
       * @returns {int} position in array, -1 if not found
       * @private
       * @memberOf MainPage
       */
      _getClipPos: function(clipText) {
        return this.clips.findIndex((clipItem) => {
          return (clipText === clipItem.text);
        });
      },

      /**
       * Get position of select row with given text
       * @param {string} clipText - text to find
       * @returns {int} position in array, -1 if not found
       * @private
       * @memberOf MainPage
       */
      _getSelectedClipPos: function(clipText) {
        return this.selectedClips.findIndex((clipItem) => {
          return (clipText === clipItem.text);
        });
      },

      /**
       * Sort list by date
       * @param {ClipItem} clipA - row to compare
       * @param {ClipItem} clipB - next row to compare
       * @returns {int} difference in dates
       * @private
       * @memberOf MainPage
       */
      _sortByDate: function(clipA, clipB) {
        return clipB.date - clipA.date;
      },

      /**
       * Filter list
       * @param {ClipItem} clip - row to check
       * @returns {boolean} true if row is visible
       * @private
       * @memberOf MainPage
       */
      _filter: function(clip) {
        return this.isFavFilter ? clip.fav : true;
      },

      /**
       * Is a {@link ClipItem} selected
       * @param {ClipItem} clipItem
       * @returns {boolean}
       * @private
       * @memberOf MainPage
       */
      _isSelected: function(clipItem) {
        const idx = this.selectedClips.findIndex((clip) => {
          return (clip.text === clipItem.text);
        });
        return (idx !== -1);
      },

      /**
       * Select {@link ClipItem} if not already
       * @param {ClipItem} clipItem
       * @private
       * @memberOf MainPage
       */
      _select: function(clipItem) {
        if (!this._isSelected(clipItem)) {
          this.push('selectedClips', clipItem);
        }
      },

      /**
       * Select first item in list, if it is not already
       * @param {boolean} [ifNoSelections=false] - if true,
       * only do if no selections
       * @private
       * @memberOf MainPage
       */
      _selectFirst: function(ifNoSelections = false) {
        this.$.clipsTemplate.render();
        if (ifNoSelections && this.selectedClips.length) {
          return;
        }
        const el = this.$$('#clip0');
        if (el) {
          const clipItem = this.$.clipsTemplate.itemForElement(el);
          if (!this._isSelected(clipItem)) {
            this.push('selectedClips', clipItem);
          }
        }
      },

      /**
       * Set clip viewer contents based on last selected
       * @private
       * @memberOf MainPage
       */
      _setCurrentClip: function() {
        let currentItem = null;
        if (this.selectedClips && this.selectedClips.length) {
          currentItem = this.selectedClips[this.selectedClips.length - 1];
        }
        this.set('currentClip', currentItem);
      },

      /**
       * Sort the {@link clips} Array by date
       * @private
       * @memberOf MainPage
       */
      _sortClipsByDate: function() {
        this.clips.sort((a, b) => {
          return b.date - a.date;
        });
        this.$.clipsTemplate.render();
      },

      /**
       * Get the labels shared by all selected {@link ClipItem} objects
       * @returns {string[]} Array of all shared Label names
       * @private
       * @memberOf MainPage
       */
      _getCommonLabelsForSelected: function() {
        const labels = [];
        this.labels.forEach((labelName) => {
          let has = true;
          for (let i = 0; i < this.selectedClips.length; i++) {
            const clipItem = this.selectedClips[i];
            if (!clipItem.hasLabel(labelName)) {
              has = false;
              break;
            }
          }
          if (has) {
            labels.push(labelName);
          }
        });
        return labels;
      },

      /**
       * Show Labels select dialog
       * @param {boolean} multi - if true apply changes to all selectItems
       * @private
       * @memberOf MainPage
       */
      _showLabelsSelectDialog: function(multi) {
        this.set('isMultiLabelsEdit', multi);
        app.Label.loadAll().then((labels) => {
          this.splice('labels', 0, this.labels.length);
          labels.forEach((label) => {
            this.push('labels', label.name);
          });
          return Promise.resolve();
        }).then(() => {
          if (multi && (this.selectedClips.length > 1)) {
            // for multi mode, will apply to all selectedClips
            const labels = this._getCommonLabelsForSelected();
            this.set('selectedDialogLabels', labels);
          } else {
            this._setSelectedLabels(this.currentClip);
          }
          return Promise.resolve();
        }).then(() => {
          this.$.labelsDialog.open();
          return Promise.resolve();
        }).catch((err) => {
          Chrome.Log.error(err.message, 'MainPage._showLabelsSelectDialog',
              'Failed to load labels');
        });
      },

      /**
       * Set the selected labels based on a {@link ClipItem}
       * @param {ClipItem} clipItem
       * @private
       * @memberOf MainPage
       */
      _setSelectedLabels: function(clipItem) {
        this.splice('selectedDialogLabels', 0, this.selectedDialogLabels.length);
        if (!clipItem) {
          return;
        }
        const names = clipItem.getLabelNames();
        names.forEach((name) => {
          this.push('selectedDialogLabels', name);
        });
      },

      /**
       * Close the Undo Toast
       * @private
       * @memberOf MainPage
       */
      _closeUndoToast: function() {
        this.splice('undoClips', 0, this.undoClips.length);
        this.$.undoToast.close();
      },
    });
  })();
</script>
