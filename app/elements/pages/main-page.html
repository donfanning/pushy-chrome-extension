<!--
  ~ Copyright (c) 2016-2017, Michael A. Updike All rights reserved.
  ~ Licensed under Apache 2.0
  ~ https://opensource.org/licenses/Apache-2.0
  ~ https://goo.gl/wFvBM1
  -->
<link rel="import" href="../../bower_components/polymer/polymer.html">

<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../../bower_components/iron-list/iron-list.html">
<link rel="import" href="../../bower_components/iron-localstorage/iron-localstorage.html">

<link rel="import" href="../../bower_components/paper-styles/typography.html">
<link rel="import" href="../../bower_components/paper-styles/color.html">
<link rel="import" href="../../bower_components/paper-material/paper-material.html">
<link rel="import" href="../../bower_components/paper-toolbar/paper-toolbar.html">
<link rel="import" href="../../bower_components/paper-toggle-button/paper-toggle-button.html">
<link rel="import" href="../../bower_components/paper-tooltip/paper-tooltip.html">
<link rel="import" href="../../bower_components/paper-dialog/paper-dialog.html">
<link rel="import" href="../../bower_components/paper-dialog-scrollable/paper-dialog-scrollable.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/paper-listbox/paper-listbox.html">
<link rel="import" href="../../bower_components/paper-item/paper-icon-item.html">
<link rel="import" href="../../bower_components/paper-item/paper-item.html">
<link rel="import" href="../../bower_components/paper-item/paper-item-body.html">
<link rel="import" href="../../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../bower_components/paper-toast/paper-toast.html">

<link rel="import" href="../my_icons.html">

<dom-module id="main-page">
  <template>
    <style include="iron-flex iron-flex-alignment iron-flex-factors iron-positioning"></style>
    <style include="shared-styles"></style>
    <style>
      :host {
        display: block;
        position: relative;
      }

      .page-content {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
      }

      .page-toolbar {
        margin-bottom: 0;
      }

      .body-content {
        padding-top: 0;
      }

      iron-icon {
        color: var(--accent-color);
      }

      paper-icon-item {
        /*stupid documentation*/
        --paper-item-focused-before: {
          background: transparent;
        };
      }

      #clipList {
        min-width: 600px;
        height: 82vh;
        overflow: hidden;
        overflow-y: scroll;
        border: 1px #CCCCCC;
        border-right-style: solid;
        padding: 0 0 32px 0;
        margin: 0;
      }

      .clip-item {
        position: relative;
        border: 1px #CCCCCC;
        border-bottom-style: solid;
        margin: 0;
        padding: 0 0 0 8px;
        cursor: pointer;
      }

      .clip-item paper-item {
        /*stupid documentation*/
        --paper-item-focused-before: {
          background: transparent;
        };
      }

      .clip-text-row {
        padding: 0 8px;
        margin: 0;
      }

      .clip-text {
        line-height: 1.2em;
        height: 2.4em;
        overflow: hidden;
        padding: 0 8px 0 4px;
        margin: 0;
      }

      .date-row {
        padding: 0 8px;
      }

      .date-text {
        color: var(--accent-color);
        text-align: center;
      }

      #clipViewer {
        height: 82vh;
        overflow: hidden;
        overflow-y: scroll;
        padding: 16px;
        margin: 0;
      }

      #clipViewerText {
        @apply(--paper-font-subhead);
        white-space: pre-wrap;
      }

      #clipViewerLabels {
        cursor: pointer;
        margin: 0;
        padding-bottom: 16px;
      }

      #clipViewerLabels paper-item {
        @apply(--paper-font-subhead);
        --paper-item: {
          min-height: 0;
          border: 2px solid rgba(0, 0, 0, .1);
          border-radius: 5px;
          background-color: rgba(0, 0, 0, .1);
          margin-right: 8px;
          margin-bottom: 8px;
          padding-left: 4px;
          padding-right: 4px;
        };
        --paper-item-disabled-color: var(--primary-text-color);
      }

      #labelsDialog {
        min-width: 25vw;
      }

      .label-item {
        cursor: pointer;
      }

      #undoToastButton {
        margin-top: 0;
        margin-bottom: 0;
        color: yellow;
      }

      .iron-selected {
        background: var(--selected-color);
      }

    </style>

    <paper-material elevation="1" class="page-content">

      <!-- Tool bar -->
      <paper-material elevation="1">
        <paper-toolbar class="page-toolbar">
          <span class="space"></span>
          <div class="middle middle-container center horizontal layout flex">
            <div class="flex">[[_computeTitle(currentClip, labelFilter)]]</div>
            <paper-icon-button
                id="send" icon="myicons:send"
                disabled$="[[!canSend]]"
                on-tap="_onSendTapped"></paper-icon-button>
            <paper-tooltip for="send" position="left" offset="0">
              Send clipboard contents
            </paper-tooltip>
            <paper-icon-button
                id="pin" icon="[[_computePinIcon(isPinFavs)]]"
                on-tap="_onPinTapped"></paper-icon-button>
            <paper-tooltip for="pin" position="left" offset="0">
              [[_computePinToolTip(isPinFavs)]]
            </paper-tooltip>
            <paper-icon-button
                id="fav" icon="[[_computeFavIcon(isFavFilter)]]"
                style$="color: [[_computeFavMenuColor(isFavFilter)]];"
                on-tap="_onFavFilterTapped"></paper-icon-button>
            <paper-tooltip for="fav" position="left" offset="0">
              [[_computeFavToolTip(isFavFilter)]]
            </paper-tooltip>
            <paper-icon-button
                id="select" icon="myicons:check-box"
                on-tap="_onSelectAllTapped"></paper-icon-button>
            <paper-tooltip for="select" position="left" offset="0">Select all items</paper-tooltip>
            <paper-icon-button
                id="deselect" icon="myicons:check-box-outline-blank"
                on-tap="_onDeselectAllTapped"></paper-icon-button>
            <paper-tooltip for="deselect" position="left" offset="0">Deselect all items</paper-tooltip>
            <paper-icon-button
                id="labels" icon="myicons:label"
                disabled$="[[!hasSelections]]"
                on-tap="_onSelectLabelsTapped"></paper-icon-button>
            <paper-tooltip for="labels" position="left" offset="0">Change labels for selected items</paper-tooltip>
            <paper-icon-button
                id="delete" icon="myicons:delete"
                disabled$="[[!hasSelections]]"
                on-tap="_onDeleteSelectedTapped"></paper-icon-button>
            <paper-tooltip for="delete" position="left" offset="0">Delete selected items</paper-tooltip>
          </div>
        </paper-toolbar>
      </paper-material>

      <!-- Content -->
      <div class="body-content horizontal layout">

        <!-- Select labels dialog -->
        <paper-dialog
            id="labelsDialog" modal
            entry-animation="scale-up-animation"
            exit-animation="fade-out-animation">
          <h2 class="vertical layout center">
            [[_computeLabelsDialogTitle(isMultiLabelsEdit, selectedClips, selectedClips.splices)]]</h2>
          <paper-dialog-scrollable>
            <paper-listbox
                multi attr-for-selected="id"
                selected-values="{{selectedDialogLabels}}">
              <template is="dom-repeat"
                        items="{{labels}}" as="label">
                <paper-icon-item id="[[label]]" class="label-item">
                  <iron-icon icon="myicons:label" item-icon></iron-icon>
                  [[label]]
                </paper-icon-item>
              </template>
            </paper-listbox>
          </paper-dialog-scrollable>
          <div class="buttons">
            <paper-button dialog-dismiss autofocus>CLOSE</paper-button>
          </div>
        </paper-dialog>

        <!-- Undo delete toast -->
        <paper-toast id="undoToast" duration="0">
          <div class="horizontal center layout">
            <span id="undoToastText">[[undoText]]</span>
            <paper-button
                id="undoToastButton"
                on-tap="_onUndoDeleteTapped">UNDO
            </paper-button>
            <paper-icon-button
                id="undoIcon"
                icon="myicons:close"
                on-tap="_onCloseToastTapped"></paper-icon-button>
          </div>
        </paper-toast>

        <!-- Main list -->
        <div id="clipList" class="no-select flex-2">
          <iron-list id=ironList items="{{clips}}" as="clip" max-physical-count="50000">
            <template id="clipsTemplate">
              <div
                  tabindex="-1"
                  class="clip-item"
                  id="clip[[index]]"
                  on-tap="_onClipRowTapped">
                <div class="clip-body flex vertical layout" tabindex="-1">
                  <paper-item class="date-row center horizontal layout">
                    <paper-icon-button
                        icon="[[_computeFavIcon(clip.fav)]]"
                        style$="color: [[_computeFavColor(clip.fav)]];"
                        on-tap="_onRowFavTapped"></paper-icon-button>
                    <paper-item-body class="date-text center flex">
                      {{_computeDate(clip.date)}}
                    </paper-item-body>
                    <paper-icon-button
                        icon="myicons:content-copy"
                        on-tap="_onRowCopyTapped"></paper-icon-button>
                  </paper-item>
                  <paper-item class="clip-text-row horizontal layout flex">
                    <paper-item-body class="clip-text vertical start-justified layout">
                      [[clip.text]]
                    </paper-item-body>
                    <paper-icon-button
                        icon="myicons:label-outline"
                        on-tap="_onRowLabelTapped"></paper-icon-button>
                  </paper-item>
                </div>
              </div>
            </template>
          </iron-list>
        </div>

        <!-- Clip Viewer -->
        <div id="clipViewer" class="flex-3">
          <div id="clipViewerLabels" on-tap="_onLabelsTapped">
            <div class="horizontal layout">
              <template
                  is="dom-repeat" id="labelsTemplate"
                  items="{{currentLabels}}" as="currentLabel">
                <paper-item disabled>[[currentLabel]]</paper-item>
              </template>
            </div>
            <hr/>
          </div>
          <div id="clipViewerText"></div>
        </div>

      </div>
    </paper-material>
    <iron-localstorage name="pinFavs" value="{{isPinFavs}}"
                       on-iron-localstorage-load-empty="_initPinFavs"></iron-localstorage>
  </template>
</dom-module>

<script>
  (function() {
    'use strict';

    new ExceptionHandler();

    const _ERR_LOAD = 'Failed to load Clips';

    let self;

    /**
     * Polymer element to display and manage {@link ClipItem} objects
     * @namespace MainPage
     */
    Polymer({
      is: 'main-page',

      properties: {
        /**
         * {@link ClipItem} currently being viewed
         * @memberOf MainPage
         */
        currentClip: {
          type: Object,
          value: null,
          notify: true,
          observer: '_currentClipChanged',
        },

        /**
         * Array of {@link ClipItem} objects filtered by {@link labelFilter}
         * @memberOf MainPage
         */
        clips: {
          type: Array,
          value: [],
          notify: true,
        },

        /**
         * Array of selected {@link ClipItem} objects
         * @memberOf MainPage
         */
        selectedClips: {
          type: Array,
          value: [],
          notify: true,
        },

        /**
         * True if we have selected items
         * @memberOf MainPage
         */
        hasSelections: {
          type: Boolean,
          computed:
              '_computeHasSelections(selectedClips.splices)',
        },

        /**
         * True if we can send the clipboard contents
         * @memberOf MainPage
         */
        canSend: {
          type: Boolean,
          value: false,
          notify: true,
        },

        /**
         * Array of {@link ClipItem} objects that have been recently deleted
         * @memberOf MainPage
         */
        undoClips: {
          type: Array,
          value: [],
          notify: true,
        },

        /**
         * Message of undo toast
         * @memberOf MainPage
         */
        undoText: {
          type: String,
          value: '',
          notify: true,
        },

        /**
         * True if we are only showing favorite items
         * @memberOf MainPage
         */
        isFavFilter: {
          type: Boolean,
          value: false,
          notify: true,
        },

        /**
         * True if we are showing favorite items at top of list
         * @memberOf MainPage
         */
        isPinFavs: {
          type: Boolean,
          value: false,
          notify: true,
          observer: '_pinFavsChanged',
        },

        /**
         * {@link Label} name for filtering our items
         * @memberOf MainPage
         */
        labelFilter: {
          type: String,
          value: null,
          notify: true,
          observer: '_labelFilterChanged',
        },

        /**
         * Array of all {@link Label} names
         * @memberOf MainPage
         */
        labels: {
          type: Array,
          value: [],
          notify: true,
        },

        /**
         * Array of all {@link Label} names for the current clip
         * @memberOf MainPage
         */
        currentLabels: {
          type: Array,
          value: [],
          notify: true,
        },

        /**
         * Array of all selected {@link Label} names in the dialog
         * @memberOf MainPage
         */
        selectedDialogLabels: {
          type: Array,
          value: [],
          notify: true,
        },

        /**
         * True if label changes in dialog should apply to all selectedClips
         * @memberOf MainPage
         */
        isMultiLabelsEdit: {
          type: Boolean,
          value: false,
          notify: true,
        },

        /**
         * True if we are performing an operation on multiple clips
         * @memberOf MainPage
         */
        isBulkOp: {
          type: Boolean,
          value: false,
          observer: '_bulkOpChanged',
        },
      },

      observers: [
        '_selectedClipsAddedOrRemoved(selectedClips.splices)',
        '_selectedDialogLabelsAddedOrRemoved(selectedDialogLabels.splices)',
      ],

      /**
       * Element is ready
       * @memberOf MainPage
       */
      ready: function() {
        self = this;
        this.set('canSend', app.Utils.canSend());
        this._loadClipItems();
      },

      /**
       * Element is attached
       * @memberOf MainPage
       */
      attached: function() {
        Chrome.Msg.listen(this._onChromeMessage);

        // listen for copy and cut events on document
        document.addEventListener('cut', this._onCopy, true);
        document.addEventListener('copy', this._onCopy, true);
      },

      /**
       * We have animated in and are now the current page
       * @memberOf MainPage
       */
      onCurrentPage: function() {
        this.set('isBulkOp', false);
        this.set('canSend', app.Utils.canSend());
        this._selectFirst(true);
        this.updateDates();
      },

      /**
       * We are not going to be current anymore
       * @memberOf MainPage
       */
      onLeavePage: function() {
        this.set('isBulkOp', false);
        this._closeUndoToast();
        this._deselectAll();
      },

      /**
       * Update the relative dates
       * @memberOf MainPage
       */
      updateDates: function() {
        if (this.isBulkOp || (this.clips === undefined)) {
          return;
        }
        for (let i = 0; i < this.clips.length; i++) {
          const date = this.clips[i].date;
          this.set(`clips.${i}.date`, date - 1);
          this.set(`clips.${i}.date`, date);
        }
      },

      /**
       * Set {@link Label} name for filtering
       * @param {?string} labelName
       * @memberOf MainPage
       */
      setLabelFilter: function(labelName) {
        this.set('labelFilter', labelName);
      },

      // noinspection JSUnusedLocalSymbols
      /**
       * Event: Fired when a message is sent from either an extension process<br>
       * (by runtime.sendMessage) or a content script (by tabs.sendMessage).
       * @see https://developer.chrome.com/extensions/runtime#event-onMessage
       * @param {Chrome.Msg.Message} request - details for the
       * @param {Object} sender - MessageSender object
       * @param {function} response - function to call once after processing
       * @returns {boolean} true if asynchronous
       * @private
       * @memberOf MainPage
       */
      _onChromeMessage: function(request, sender, response) {
        let ret = false;
        if (request.message === app.ChromeMsg.CLIP_ITEM_CREATED.message) {
          ret = true; // async
          self._addClipItem(request.item);
        } else if (request.message === app.ChromeMsg.CLIP_ITEM_UPDATED.message) {
          const item = request.item;
          self._updateClipItem(item.text, item.mods);
        } else if (request.message === app.ChromeMsg.CLIP_ITEM_DELETED.message) {
          self._deleteClipItem(request.item);
        }
        return ret;
      },

      /**
       * Event: Select labels menu icon tapped
       * @private
       * @memberOf MainPage
       */
      _onSelectLabelsTapped: function() {
        Chrome.GA.event(Chrome.GA.EVENT.ICON, 'selectLabels');
        this._showLabelsSelectDialog(true);
      },

      /**
       * Event: Labels section of ClipViewer tapped
       * @private
       * @memberOf MainPage
       */
      _onLabelsTapped: function() {
        Chrome.GA.event(app.GA.EVENT.CLICK, 'showLabelList');
        this._showLabelsSelectDialog(false);
      },

      /**
       * Event: Undo Toast close button tapped
       * @private
       * @memberOf MainPage
       */
      _onCloseToastTapped: function() {
        Chrome.GA.event(app.GA.EVENT.IMAGE_BUTTON, 'closeUndoToast');
        this._closeUndoToast();
      },

      /**
       * Event: Undo Toast button tapped<br />
       * Restore the deleted Items
       * @private
       * @memberOf MainPage
       */
      _onUndoDeleteTapped: function() {
        Chrome.GA.event(Chrome.GA.EVENT.BUTTON, 'UNDO');
        const addItems = [];
        this.undoClips.forEach((undoClip) => {
          addItems.push(undoClip);
        });
        // skip updates until done with bulkPut
        this.set('isBulkOp', true);
        app.ClipItem.bulkPut(addItems).then(() => {
          this.set('isBulkOp', false);
          this._closeUndoToast();
          // reset selections
          this.push('selectedClips', ...addItems);
          return Promise.resolve();
        }).catch(() => {
          this.set('isBulkOp', false);
          this._closeUndoToast();
        });
      },

      /**
       * Event: Select all menu icon tapped
       * @private
       * @memberOf MainPage
       */
      _onSelectAllTapped: function() {
        Chrome.GA.event(Chrome.GA.EVENT.ICON, 'selectAllClipItems');
        this._deselectAll();
        const clipItems = [];
        for (let i = this.clips.length - 1; i >= 0; i--) {
          const clipItem = this.clips[i];
          clipItems.push(clipItem);
        }
        this.push('selectedClips', ...clipItems);
      },

      /**
       * Event: Deselect all menu icon tapped
       * @private
       * @memberOf MainPage
       */
      _onDeselectAllTapped: function() {
        Chrome.GA.event(Chrome.GA.EVENT.ICON, 'deselectAllClipItems');
        this._deselectAll();
      },

      /**
       * Event: Delete menu icon tapped
       * @private
       * @memberOf MainPage
       */
      _onDeleteSelectedTapped: function() {
        Chrome.GA.event(Chrome.GA.EVENT.ICON, 'deleteSelectedClipItems');

        // save items for undo
        const keys = [];
        this.splice('undoClips', 0, this.undoClips.length);
        this.selectedClips.forEach((selectedClip) => {
          keys.push(selectedClip._id);
          this.push('undoClips', selectedClip);
        });

        if (keys.length) {
          // skip updates until bulk operation is complete
          this.set('isBulkOp', true);
          app.ClipItem.remove(keys).then(() => {
            this._deselectAll();
            this.set('isBulkOp', false);
            const len = this.undoClips.length;
            let toastText =
                (len === 1) ? 'Deleted 1 item.' : `Deleted ${len} items.`;
            this.set('undoText', toastText);
            this.$.undoToast.show();
            return Promise.resolve();
          }).catch((err) => {
            this.set('isBulkOp', false);
            Chrome.Log.error(err.message, 'MainPage._onDeleteSelectedRows',
                'Failed to delete clips.');
          });
        }
      },

      /**
       * Event: Send clipboard contents icon tapped
       * @private
       * @memberOf MainPage
       */
      _onSendTapped: function() {
        Chrome.GA.event(Chrome.GA.EVENT.ICON, 'sendClipboardContents');
        Chrome.Msg.send(app.ChromeMsg.COPIED_TO_CLIPBOARD).catch(() => {});
      },

      /**
       * Event: Pin menu icon tapped
       * @private
       * @memberOf MainPage
       */
      _onPinTapped: function() {
        this.set('isPinFavs', !this.isPinFavs);
        Chrome.GA.event(Chrome.GA.EVENT.ICON, `pinFavorites: ${this.isPinFavs}`);
      },

      /**
       * Event: Favorite filter menu icon tapped
       * @private
       * @memberOf MainPage
       */
      _onFavFilterTapped: function() {
        this.set('isFavFilter', !this.isFavFilter);
        Chrome.GA.event(Chrome.GA.EVENT.ICON,
            `filterByFavorites: ${this.isFavFilter}`);

        this._loadClipItems(true).catch((err) => {
          Chrome.Log.error(err.message, 'MainPage._onFavFilterTapped',
              'Failed to load clips.');
        });
      },

      /**
       * Event: Tap on clip row - handle selections like a tree select
       * @param {Event} event
       * @param {ClipItem} event.model.clip
       * @private
       * @memberOf MainPage
       */
      _onClipRowTapped: function(event) {
        Chrome.GA.event(app.GA.EVENT.CLICK, 'clipItemRow');
        const isShift = event.detail.sourceEvent.shiftKey;
        const isCtrl = event.detail.sourceEvent.ctrlKey;
        const endPos = event.model.index;
        const currentClipItem = this.clips[endPos];
        let selected = this._isSelected(currentClipItem);

        if (isShift) {
          // select range
          let startPos = -1;
          if (selected) {
            // deselect any contiguous selections after 
            for (let i = endPos + 1; i < this.clips.length; i++) {
              const clipItem = this.clips[i];
              if (!this._deselect(clipItem)) {
                break;
              }
            }
            return;
          } else if (!this.hasSelections) {
            // select from first to current
            startPos = 0;
          } else {
            for (let i = endPos - 1; i >= 0; i--) {
              // select from after newer selection to current
              const clipItem = this.clips[i];
              if (this._isSelected(clipItem)) {
                startPos = i;
                break;
              }
            }
            if (startPos === -1) {
              // try the other direction
              for (let i = endPos + 1; i < this.clips.length; i++) {
                // select from before older selection to current
                const clipItem = this.clips[i];
                if (this._isSelected(clipItem)) {
                  startPos = i;
                  break;
                }
              }
            }
          }
          if (startPos !== -1) {
            // found range, select it
            const clipItems = [];
            if (startPos < endPos) {
              for (let i = startPos + 1; i <= endPos; i++) {
                const clipItem = this.clips[i];
                clipItems.push(clipItem);
              }
            } else if (startPos > endPos) {
              for (let i = startPos - 1; i >= endPos; i--) {
                const clipItem = this.clips[i];
                clipItems.push(clipItem);
              }
            }
            this.push('selectedClips', ...clipItems);
          }
        } else if (isCtrl) {
          // toggle selection
          if (selected) {
            this._deselect(currentClipItem);
          } else {
            this._select(currentClipItem);
          }
        } else {
          // single select with toggle
          const len = this.selectedClips.length;
          this._deselectAll();
          if (!selected || (len > 1)) {
            this._select(currentClipItem);
          }
        }
      },

      /**
       * Event: Copy list row to clipboard
       * @param {Event} event
       * @param {ClipItem} event.model.clip
       * @private
       * @memberOf MainPage
       */
      _onRowCopyTapped: function(event) {
        Chrome.GA.event(app.GA.EVENT.IMAGE_BUTTON, 'copyClipItem');
        const clipItem = event.model.clip;
        clipItem.date = Date.now();
        clipItem.remote = false;
        clipItem.save().then(() => {
          // send message to copy to clipboard
          const msg =
              Chrome.JSONUtils.shallowCopy(app.ChromeMsg.COPY_TO_CLIPBOARD);
          msg.item = clipItem;
          // eslint-disable-next-line promise/no-nesting
          Chrome.Msg.send(msg).catch(() => {});
          return Promise.resolve();
        }).catch((err) => {
          Chrome.Log.error(err.message, 'MainPage._onRowCopyTapped',
              'Failed to copy item to clipboard.');
        });

        // prevent row selection
        event.stopPropagation();
      },

      /**
       * Event: Toggle favorite state of row
       * @param {Event} event
       * @param {ClipItem} event.model.clip
       * @private
       * @memberOf MainPage
       */
      _onRowFavTapped: function(event) {
        Chrome.GA.event(app.GA.EVENT.IMAGE_BUTTON, 'toggleFavorite');
        const clipItem = event.model.clip;
        if (clipItem) {
          clipItem.update({fav: !clipItem.fav}).catch((err) => {
            Chrome.Log.error(err.message, 'MainPage._onRowFavTapped');
          });
        }

        // prevent row selection
        event.stopPropagation();
      },

      /**
       * Event: Label icon of clip row tapped
       * @param {Event} event
       * @param {{}} event.model
       * @private
       * @memberOf MainPage
       */
      _onRowLabelTapped: function(event) {
        Chrome.GA.event(app.GA.EVENT.IMAGE_BUTTON, 'showLabelList');
        const clipItem = event.model.clip;
        this._deselectAll();
        this._select(clipItem);
        // prevent row deselection
        event.stopPropagation();
        this._showLabelsSelectDialog(false);
      },

      /**
       * Event: Text was copied to clipboard
       * @private
       * @memberOf MainPage
       */
      _onCopy: function() {
        Chrome.Msg.send(app.ChromeMsg.COPIED_TO_CLIPBOARD).catch(() => {});
      },

      /**
       * Event: Initialize pinFavs if it is not in localStorage
       * @private
       * @memberOf MainPage
       */
      _initPinFavs: function() {
        this.set('isPinFavs', 'false');
      },

      /**
       * Observer: The current clip changed
       * @private
       * @memberOf MainPage
       */
      _currentClipChanged: function() {
        this.updateDates();

        // clear text
        const el = this.$.clipViewerText;
        while (el.firstChild) {
          // delete all children previous linkify created
          el.removeChild(el.firstChild);
        }

        // set the current labels

        // not guaranteed to be initialized yet
        if (this.currentLabels === undefined) {
          this.currentLabels = [];
        }
        this.$.clipViewerLabels.style.display = 'none';
        this.splice('currentLabels', 0, this.currentLabels.length);

        const clipItem = this.currentClip;
        if (!clipItem) {
          return;
        }

        const names = clipItem.getLabelNames();
        names.forEach((name) => {
          if (!this.currentLabels.includes(name)) {
            this.push('currentLabels', name);
          }
        });

        if (this.currentLabels && this.currentLabels.length) {
          this.$.clipViewerLabels.style.display = 'block';
        }

        // set text
        el.textContent = clipItem.text;
        // linkify it - creates element children
        linkifyElement(el);
      },

      /**
       * Observer: The label filter changed
       * @param {string} newValue
       * @param {string|undefined} oldValue
       * @private
       * @memberOf MainPage
       */
      _labelFilterChanged: function(newValue, oldValue) {
        if (typeof(oldValue) !== 'undefined') {
          this._deselectAll();
          this._loadClipItems().catch((err) => {
            Chrome.Log.error(err.message, 'MainPage.setLabelFilter', _ERR_LOAD);
          });
        }
      },

      /**
       * Observer: The pinFavs setting changed
       * @param {boolean} newValue
       * @param {boolean|undefined} oldValue
       * @private
       * @memberOf MainPage
       */
      _pinFavsChanged: function(newValue, oldValue) {
        if (typeof(oldValue) !== 'undefined') {
          this._sortClips();
        }
      },

      /**
       * Observer: The bulkOp setting changed
       * @param {boolean} newValue
       * @param {boolean|undefined} oldValue
       * @private
       * @memberOf MainPage
       */
      _bulkOpChanged: function(newValue, oldValue) {
        if (typeof(oldValue) !== 'undefined') {
          if (!newValue && oldValue) {
            // toggling from true to false
            if (this.clips && this.clips.length) {
              this._sortClips();
            } else {
              // no clips
              this.set('clips', []);
            }
          }
        }
      },

      /**
       * Observer: selectedClips Array mutations
       * @param {{}} changeRecord
       * @private
       * @memberOf MainPage
       */
      _selectedClipsAddedOrRemoved: function(changeRecord) {
        if (!this.isBulkOp && changeRecord) {
          changeRecord.indexSplices.forEach((splice) => {
            splice.removed.forEach(function(clipItem) {
              const pos = this._getClipPos(clipItem.text);
              const el = this.$$(`#clip${pos}`);
              if (el) {
                el.classList.remove('iron-selected');
              }
            }, this);
            for (let i = 0; i < splice.addedCount; i++) {
              const index = splice.index + i;
              const clipItem = splice.object[index];
              const pos = this._getClipPos(clipItem.text);
              const el = this.$$(`#clip${pos}`);
              if (el) {
                el.classList.add('iron-selected');
              }
            }
          }, this);
          this._setCurrentClip();
        }
      },

      /**
       * Observer: selectedDialogLabels Array mutations
       * @param {{}} changeRecord
       * @private
       * @memberOf MainPage
       */
      _selectedDialogLabelsAddedOrRemoved: function(changeRecord) {
        if (changeRecord) {
          this.set('isBulkOp', true);
          const promises = [];
          if (this.isMultiLabelsEdit) {
            // track each added and removed label change and
            // apply to each selected clip
            const addedNames = [];
            const removedNames = [];
            const splices = changeRecord.indexSplices;
            splices.forEach((splice) => {
              for (let i = 0; i < splice.addedCount; i++) {
                let index = splice.index + i;
                addedNames.push(splice.object[index]);
              }
              splice.removed.forEach((name) => {
                removedNames.push(name);
              });
            });
            this.selectedClips.forEach((clipItem) => {
              const names = clipItem.getLabelNames();
              addedNames.forEach((addedName) => {
                if (!clipItem.hasLabel(addedName)) {
                  names.push(addedName);
                }
              });
              removedNames.forEach((removedName) => {
                if (clipItem.hasLabel(removedName)) {
                  const idx = names.indexOf(removedName);
                  names.splice(idx, 1);
                }
              });
              promises.push(clipItem.setLabels(names));
            });
          } else {
            const clipItem = this.currentClip;
            promises.push(clipItem.setLabels(this.selectedDialogLabels));
          }

          Promise.all(promises).then(() => {
            this.set('isBulkOp', false);
            if (this.labelFilter &&
                !this.selectedDialogLabels.includes(this.labelFilter)) {
              // deleted current label from item(s) 
              this.$.labelsDialog.close();
              return this._loadClipItems();
            } else {
              this._setCurrentClip();
              return Promise.resolve();
            }
          }).catch((err) => {
            this.set('isBulkOp', false);
            Chrome.Log.error(err.errorMessage,
                'MainPage._onSelectedLabelsChanged', 'Failed to set label.');
          });
        }
      },

      /**
       * Computed Property: Do we have selected items
       * @returns {boolean}
       * @private
       * @memberOf MainPage
       */
      _computeHasSelections: function() {
        return !!(this.selectedClips && this.selectedClips.length);
      },

      /**
       * Computed Binding
       * @param {ClipItem} clipItem
       * @param {string} labelName
       * @returns {string} Page title
       * @private
       * @memberOf MainPage
       */
      _computeTitle: function(clipItem, labelName) {
        let title = 'Clips';
        if (!Chrome.Utils.isWhiteSpace(labelName)) {
          title = `${labelName}`;
        }
        if (clipItem) {
          if (clipItem.remote) {
            title += `: Remote clip - ${clipItem.device}`;
          } else {
            title += ': Local clip';
          }
        }
        return title;
      },

      /**
       * Computed Binding: Title of Labels Dialog
       * @param {boolean} multi - true if dialog applies to all selectedClips
       * @returns {string} Dialog title
       * @private
       * @memberOf MainPage
       */
      _computeLabelsDialogTitle: function(multi) {
        if (multi && this.selectedClips && (this.selectedClips.length > 1)) {
          return 'Change labels for selected clips';
        } else {
          return 'Set labels for the current clip';
        }
      },

      /**
       * Computed Binding
       * @param {boolean} isTrue - true if we should pin favs to top
       * @returns {string} icon style
       * @private
       * @memberOf MainPage
       */
      _computePinIcon: function(isTrue) {
        return isTrue ? 'myicons:pin' : 'myicons:pin-off';
      },

      /**
       * Computed Binding
       * @param {boolean} isTrue - true if fav
       * @returns {string} icon style
       * @private
       * @memberOf MainPage
       */
      _computeFavIcon: function(isTrue) {
        return isTrue ? 'myicons:favorite' : 'myicons:favorite-border';
      },

      /**
       * Computed Binding
       * @param {boolean} isTrue - true if pinning favorites
       * @returns {string} tooltip text of what toggling would be
       * @private
       * @memberOf MainPage
       */
      _computePinToolTip: function(isTrue) {
        return isTrue ? 'Unpin favorites' : 'Pin favorites to top';
      },

      /**
       * Computed Binding
       * @param {boolean} isTrue - true if fav
       * @returns {string} Favorite icon color
       * @private
       * @memberOf MainPage
       */
      _computeFavColor: function(isTrue) {
        return isTrue ? 'rgba(255, 0, 0, .8)' : 'var(--primary-text-color)';
      },

      /**
       * Computed Binding
       * @param {boolean} isTrue - true if fav
       * @returns {string} fav filter menu icon color
       * @private
       * @memberOf MainPage
       */
      _computeFavMenuColor: function(isTrue) {
        return isTrue ? 'rgba(255, 0, 0, .8)' : 'var(--menu-icon-color)';
      },

      /**
       * Computed Binding
       * @param {boolean} isFilter - true if filtering by fav
       * @returns {string} tooltip text of what toggling would be
       * @private
       * @memberOf MainPage
       */
      _computeFavToolTip: function(isFilter) {
        return isFilter ? 'Show all' : 'Show favorites only';
      },

      /**
       * Computed Binding
       * @param {int} date - from epoch in millis
       * @returns {string} Date as relative from now
       * @private
       * @memberOf MainPage
       */
      _computeDate: function(date) {
        return app.Utils.getRelativeTime(date);
      },

      /**
       * Load the {@link ClipItem} objects
       * @param {boolean} [selectFirst=true] - if true select first item
       * @returns {Promise<void>}
       * @private
       * @memberOf MainPage
       */
      _loadClipItems: function(selectFirst = true) {
        this._closeUndoToast();
        this.splice('clips', 0, this.clips.length);
        this._deselectAll();
        return app.ClipItem.loadAll(this.labelFilter).then((clipItems) => {
          this.set('isBulkOp', true);
          // populate list
          if (this.isFavFilter) {
            // favorites only
            clipItems.forEach((clipItem) => {
              if (clipItem.fav) {
                this.clips.push(clipItem);
              }
            });
          } else {
            this.clips.push(...clipItems);
          }
          this.set('isBulkOp', false);
          if (selectFirst) {
            this._selectFirst();
            this.$.clipList.scrollTop = 0;
          }
          return Promise.resolve();
        });
      },

      /**
       * Sort the {@link ClipItem} list
       * @private
       * @memberOf MainPage
       */
      _sortClips: function() {
        if (this.isBulkOp) {
          return;
        }
        if (this.isPinFavs) {
          // sort favs and non-favs separately and keep favs on top
          const favClips = this.clips.filter((clip) => {
            return clip.fav;
          });
          favClips.sort((a, b) => {
            return b.date - a.date;
          });
          const nonFavClips = this.clips.filter((clip) => {
            return !clip.fav;
          });
          nonFavClips.sort((a, b) => {
            return b.date - a.date;
          });
          this.splice('clips', 0, this.clips.length);
          // populate list
          this.push('clips', ...favClips);
          this.push('clips', ...nonFavClips);
        } else {
          // sort by date
          const clips = this.clips.filter(() => {
            return true;
          });
          clips.sort((a, b) => {
            return b.date - a.date;
          });
          this.splice('clips', 0, this.clips.length);
          this.push('clips', ...clips);
        }
        this._updateSelectionClasses();
      },

      /**
       * Add a {@link ClipItem} to the list
       * @param {string} text - ClipItem text
       * @private
       * @memberOf MainPage
       */
      _addClipItem: function(text) {
        app.ClipItem.getNew(text).then((clipItem) => {
          if (this._getClipPos(clipItem.text) === -1) {
            if (!this.labelFilter || clipItem.hasLabel(this.labelFilter)) {
              // add to list if not filtering or has our labelFiler
              if (this.isBulkOp) {
                this.clips.unshift(clipItem);
              } else {
                this.unshift('clips', clipItem);
                this._sortClips();
              }
            }
          }
          return Promise.resolve();
        }).catch((err) => {
          Chrome.Log.error(err.message, 'MainPage._addClipItem',
              'Failed to add clip item');
        });
      },

      /**
       * Update a {@link ClipItem} in the list
       * @param {string} text - ClipItem text
       * @param {Object} mods - key/value pairs of changes
       * @private
       * @memberOf MainPage
       */
      _updateClipItem: function(text, mods) {
        const pos = this._getClipPos(text);
        if (pos !== -1) {
          let needsSort = false;
          const str = `clips.${pos}.`;
          for (const key of Object.keys(mods)) {
            // check if props that affect sort changed
            if (key === 'fav') {
              if (this.isPinFavs && (mods[key] !== this.clips[pos].fav)) {
                needsSort = true;
              }
            }
            this.set(`${str}${key}`, mods[key]);
          }

          if (this.currentClip &&
              (this.clips[pos].text === this.currentClip.text) &&
              mods.hasOwnProperty('labels')) {
            // update clip if labels changed
            this._setCurrentClip();
          }

          if (!needsSort && mods.hasOwnProperty('date')) {
            needsSort = true;
          }
          if (needsSort) {
            this._sortClips();
          } else {
            this.updateDates();
          }
        }
      },

      /**
       * Delete a {@link ClipItem} from the list
       * @param {string} text - ClipItem text
       * @private
       * @memberOf MainPage
       */
      _deleteClipItem: function(text) {
        const pos = this._getClipPos(text);
        if (pos !== -1) {
          if (this.isBulkOp) {
            this.clips.splice(pos, 1);
          } else {
            this.splice('clips', pos, 1);
            this.updateDates();
          }
        }
      },

      /**
       * Get clip from text
       * @param {string} clipText - text to find
       * @returns {?ClipItem} null if not found
       * @private
       * @memberOf MainPage
       */
      _getClip: function(clipText) {
        return this.clips.find((clipItem) => {
          return (clipText === clipItem.text);
        });
      },

      /**
       * Get position of row with given text
       * @param {string} clipText - text to find
       * @returns {int} position in array, -1 if not found
       * @private
       * @memberOf MainPage
       */
      _getClipPos: function(clipText) {
        return this.clips.findIndex((clipItem) => {
          return (clipText === clipItem.text);
        });
      },

      /**
       * Is a {@link ClipItem} selected
       * @param {ClipItem} clipItem
       * @returns {boolean}
       * @private
       * @memberOf MainPage
       */
      _isSelected: function(clipItem) {
        const idx = this.selectedClips.findIndex((clip) => {
          return (clip.text === clipItem.text);
        });
        return (idx !== -1);
      },

      /**
       * Update all the selection classLists
       * @private
       * @memberOf MainPage
       */
      _updateSelectionClasses: function() {
        Polymer.dom.flush();
        this.clips.forEach((clipItem) => {
          const pos = this._getClipPos(clipItem.text);
          const el = this.$$(`#clip${pos}`);
          if (el) {
            el.classList.remove('iron-selected');
          }
        });
        this.selectedClips.forEach((clipItem) => {
          const pos = this._getClipPos(clipItem.text);
          const el = this.$$(`#clip${pos}`);
          if (el) {
            el.classList.add('iron-selected');
          }
        });
      },

      /**
       * Select {@link ClipItem} if not already
       * @param {ClipItem} clipItem
       * @returns {boolean} true if selected
       * @private
       * @memberOf MainPage
       */
      _select: function(clipItem) {
        if (clipItem && !this._isSelected(clipItem)) {
          this.push('selectedClips', clipItem);
          return true;
        }
        return false;
      },

      /**
       * Deselect {@link ClipItem} if not already
       * @param {ClipItem} clipItem
       * @returns {boolean} true if deselected
       * @private
       * @memberOf MainPage
       */
      _deselect: function(clipItem) {
        if (!clipItem) {
          return false;
        }
        const idx = this.selectedClips.findIndex((clip) => {
          return (clip.text === clipItem.text);
        });
        if (this._isSelected(clipItem)) {
          this.splice('selectedClips', idx, 1);
          return true;
        }
        return false;
      },

      /**
       * Deselect all {@link ClipItem}
       * @private
       * @memberOf MainPage
       */
      _deselectAll: function() {
        if (this.selectedClips && this.selectedClips.length) {
          this.splice('selectedClips', 0, this.selectedClips.length);
        }
      },

      /**
       * Select first item in list, if it is not already
       * @param {boolean} [ifNoSelections=false] - if true,
       * only do if no selections
       * @returns {boolean} true if selected
       * @private
       * @memberOf MainPage
       */
      _selectFirst: function(ifNoSelections = false) {
        if (!this.clips || !this.clips.length ||
            (ifNoSelections && this.selectedClips.length)) {
          return false;
        }
        const clipItem = this.clips[0];
        return this._select(clipItem);
      },

      /**
       * Set clip viewer contents based on last selected
       * @private
       * @memberOf MainPage
       */
      _setCurrentClip: function() {
        let currentItem = null;
        if (this.selectedClips && this.selectedClips.length) {
          currentItem = this.selectedClips[this.selectedClips.length - 1];
        }
        // override dirty checking
        this.set('currentClip', null);
        this.set('currentClip', currentItem);
      },

      /**
       * Get the labels shared by all selected {@link ClipItem} objects
       * @returns {string[]} Array of all shared Label names
       * @private
       * @memberOf MainPage
       */
      _getCommonLabelsForSelected: function() {
        const labels = [];
        this.labels.forEach((labelName) => {
          let has = true;
          for (let i = 0; i < this.selectedClips.length; i++) {
            const clipItem = this.selectedClips[i];
            if (!clipItem.hasLabel(labelName)) {
              has = false;
              break;
            }
          }
          if (has) {
            labels.push(labelName);
          }
        });
        return labels;
      },

      /**
       * Show Labels select dialog
       * @param {boolean} multi - if true apply changes to all selectItems
       * @private
       * @memberOf MainPage
       */
      _showLabelsSelectDialog: function(multi) {
        this.set('isMultiLabelsEdit', multi);
        app.Label.loadAll().then((labels) => {
          this.splice('labels', 0, this.labels.length);
          labels.forEach((label) => {
            this.push('labels', label.name);
          });
          return Promise.resolve();
        }).then(() => {
          if (multi && (this.selectedClips.length > 1)) {
            // for multi mode, will apply to all selectedClips
            const labels = this._getCommonLabelsForSelected();
            this.set('selectedDialogLabels', labels);
          } else {
            this._setSelectedLabels(this.currentClip);
          }
          return Promise.resolve();
        }).then(() => {
          this.$.labelsDialog.open();
          return Promise.resolve();
        }).catch((err) => {
          Chrome.Log.error(err.message, 'MainPage._showLabelsSelectDialog',
              'Failed to load labels');
        });
      },

      /**
       * Set the selected labels based on a {@link ClipItem}
       * @param {ClipItem} clipItem
       * @private
       * @memberOf MainPage
       */
      _setSelectedLabels: function(clipItem) {
        if (this.selectedDialogLabels && this.selectedDialogLabels.length) {
          this.splice('selectedDialogLabels', 0,
              this.selectedDialogLabels.length);
        }
        if (clipItem) {
          const names = clipItem.getLabelNames();
          this.push('selectedDialogLabels', ...names);
        }
      },

      /**
       * Close the Undo Toast
       * @private
       * @memberOf MainPage
       */
      _closeUndoToast: function() {
        if (this.undoClips && this.undoClips.length) {
          this.splice('undoClips', 0, this.undoClips.length);
        }
        this.$.undoToast.close();
      },
    });

    /**
     * Document and resources loaded
     * @private
     * @memberOf MainPage
     */
    function _onLoad() {
      const db = app.DB.get();
      if (!db) {
        Chrome.Log.error('Failed to get database reference', 'MainPage._onLoad',
            'Database not found');
        return;
      }

      db.clipItems.hook('creating', function(primKey, obj) {
        // eslint-disable-next-line no-invalid-this
        this.onsuccess = function() {
          self._addClipItem(obj.text);
        };
      });

      db.clipItems.hook('updating', function(mods, primKey, obj) {
        // eslint-disable-next-line no-invalid-this
        this.onsuccess = function() {
          self._updateClipItem(obj.text, mods);
        };
      });

      db.clipItems.hook('deleting', function(primKey, obj) {
        // eslint-disable-next-line no-invalid-this
        this.onsuccess = function() {
          self._deleteClipItem(obj.text);
        };
      });
    }

    // listen for document and resources loaded
    window.addEventListener('load', _onLoad);
  })();
</script>
